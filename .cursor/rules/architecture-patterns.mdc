---
alwaysApply: true
---

# Architecture Patterns & Best Practices

## üèóÔ∏è S√©paration des Responsabilit√©s

### Composants (UI Layer)

- **R√¥le** : Pr√©sentation et interaction utilisateur uniquement
- **Interdictions** :
  - ‚ùå Appeler directement les services
  - ‚ùå G√©rer la logique m√©tier
  - ‚ùå Manipuler les donn√©es brutes
  - ‚ùå G√©rer l'√©tat global

### Stores (State Management)

- **R√¥le** : Gestion de l'√©tat global et orchestration des services
- **Responsabilit√©s** :
  - ‚úÖ Centraliser l'√©tat de l'application
  - ‚úÖ Appeler les services appropri√©s
  - ‚úÖ G√©rer les √©tats de chargement/erreur
  - ‚úÖ Exposer des m√©thodes pour les composants

### Services (Business Logic)

- **R√¥le** : Logique m√©tier et communication avec l'API
- **Responsabilit√©s** :
  - ‚úÖ G√©rer les appels API
  - ‚úÖ Transformer les donn√©es
  - ‚úÖ G√©rer les erreurs m√©tier
  - ‚úÖ Impl√©menter la logique business

## üìã Patterns Recommand√©s

### 1. Flux de Donn√©es Correct

```
Composant ‚Üí Store ‚Üí Service ‚Üí Repository/API
```

### 2. Structure de Store Typique

```typescript
// ‚úÖ Bon pattern
export const useMyStore = defineStore("myStore", () => {
  // √âtat
  const data = ref(null);
  const loading = ref(false);
  const error = ref(null);

  // Actions m√©tier
  const fetchData = async () => {
    loading.value = true;
    try {
      const service = await import("~/services/myService");
      data.value = await service.getData();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  };

  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    fetchData,
  };
});
```

### 3. Structure de Composant Correcte

```typescript
// ‚úÖ Bon pattern
const handleAction = async () => {
  try {
    await store.actionMethod();
  } catch (error) {
    // Gestion UI de l'erreur uniquement
    toast.add({ title: "Erreur", color: "error" });
  }
};
```

## ‚ùå Anti-Patterns √† √âviter

### 1. Service Direct dans Composant

```typescript
// ‚ùå MAUVAIS
const handleAction = async () => {
  const { myService } = await import("~/services/myService");
  await myService.doSomething();
};
```

### 2. Logique M√©tier dans Composant

```typescript
// ‚ùå MAUVAIS
const processData = (data) => {
  // Logique m√©tier ici
  return data.map((item) => ({ ...item, processed: true }));
};
```

### 3. √âtat Local Redondant

```typescript
// ‚ùå MAUVAIS
const localLoading = ref(false); // Si le store a d√©j√† loading
```

## üîß Bonnes Pratiques Suppl√©mentaires

### 1. Gestion des Erreurs

- **Store** : Capture et stocke les erreurs
- **Composant** : Affiche les erreurs de mani√®re appropri√©e
- **Service** : L√®ve des erreurs avec des messages clairs

### 2. √âtats de Chargement

- Centraliser dans le store
- √âviter les √©tats locaux redondants
- Utiliser des computed pour les √©tats d√©riv√©s

### 3. Imports Dynamiques

- Toujours utiliser `await import()` pour les services
- √âviter les imports statiques des services dans les composants

### 4. Props et √âmits

- Props : Donn√©es descendantes
- √âmits : √âv√©nements ascendants
- √âviter les props pour les callbacks

### 5. Composables

- R√©utiliser la logique commune
- S√©parer les pr√©occupations
- √âviter les composables trop gros

## üéØ Exemples Concrets

### ‚úÖ Bon Pattern (Selection)

```typescript
// Store
const downloadAllImagesAsZip = async () => {
  const { selectionService } = await import("~/services/selectionService");
  await selectionService.downloadAllImagesAsZip(selection.value.id);
};

// Composant
const handleDownload = async () => {
  try {
    await selectionStore.downloadAllImagesAsZip();
  } catch (error) {
    toast.add({ title: "Erreur", color: "error" });
  }
};
```

### ‚ùå Anti-Pattern

```typescript
// Composant
const handleDownload = async () => {
  const { selectionService } = await import("~/services/selectionService");
  await selectionService.downloadAllImagesAsZip(selectionId);
};
```

## üìù Checklist de V√©rification

Avant de commiter, v√©rifiez :

- [ ] Les composants n'appellent pas directement les services
- [ ] La logique m√©tier est dans les services/stores
- [ ] Les composants sont focalis√©s sur l'UI
- [ ] Les √©tats sont centralis√©s dans les stores
- [ ] Pas de duplication de logique
- [ ] Gestion d'erreurs appropri√©e √† chaque niveau

## üöÄ Optimisations Avanc√©es

### 1. Cache et Performance

- Utiliser des computed pour les donn√©es d√©riv√©es
- Impl√©menter du cache dans les stores
- √âviter les recalculs inutiles

### 2. Tests

- Tester les services ind√©pendamment
- Mocker les stores pour tester les composants
- Tester la logique m√©tier s√©par√©ment de l'UI

### 3. TypeScript

- Typage strict des stores
- Interfaces claires pour les services
- Props typ√©es pour les composants

Cette architecture garantit une maintenance facile, une r√©utilisabilit√© maximale et une s√©paration claire des responsabilit√©s.

# Architecture Patterns & Best Practices

## üèóÔ∏è S√©paration des Responsabilit√©s

### Composants (UI Layer)

- **R√¥le** : Pr√©sentation et interaction utilisateur uniquement
- **Interdictions** :
  - ‚ùå Appeler directement les services
  - ‚ùå G√©rer la logique m√©tier
  - ‚ùå Manipuler les donn√©es brutes
  - ‚ùå G√©rer l'√©tat global

### Stores (State Management)

- **R√¥le** : Gestion de l'√©tat global et orchestration des services
- **Responsabilit√©s** :
  - ‚úÖ Centraliser l'√©tat de l'application
  - ‚úÖ Appeler les services appropri√©s
  - ‚úÖ G√©rer les √©tats de chargement/erreur
  - ‚úÖ Exposer des m√©thodes pour les composants

### Services (Business Logic)

- **R√¥le** : Logique m√©tier et communication avec l'API
- **Responsabilit√©s** :
  - ‚úÖ G√©rer les appels API
  - ‚úÖ Transformer les donn√©es
  - ‚úÖ G√©rer les erreurs m√©tier
  - ‚úÖ Impl√©menter la logique business

## üìã Patterns Recommand√©s

### 1. Flux de Donn√©es Correct

```
Composant ‚Üí Store ‚Üí Service ‚Üí Repository/API
```

### 2. Structure de Store Typique

```typescript
// ‚úÖ Bon pattern
export const useMyStore = defineStore("myStore", () => {
  // √âtat
  const data = ref(null);
  const loading = ref(false);
  const error = ref(null);

  // Actions m√©tier
  const fetchData = async () => {
    loading.value = true;
    try {
      const service = await import("~/services/myService");
      data.value = await service.getData();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  };

  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    fetchData,
  };
});
```

### 3. Structure de Composant Correcte

```typescript
// ‚úÖ Bon pattern
const handleAction = async () => {
  try {
    await store.actionMethod();
  } catch (error) {
    // Gestion UI de l'erreur uniquement
    toast.add({ title: "Erreur", color: "error" });
  }
};
```

## ‚ùå Anti-Patterns √† √âviter

### 1. Service Direct dans Composant

```typescript
// ‚ùå MAUVAIS
const handleAction = async () => {
  const { myService } = await import("~/services/myService");
  await myService.doSomething();
};
```

### 2. Logique M√©tier dans Composant

```typescript
// ‚ùå MAUVAIS
const processData = (data) => {
  // Logique m√©tier ici
  return data.map((item) => ({ ...item, processed: true }));
};
```

### 3. √âtat Local Redondant

```typescript
// ‚ùå MAUVAIS
const localLoading = ref(false); // Si le store a d√©j√† loading
```

## üîß Bonnes Pratiques Suppl√©mentaires

### 1. Gestion des Erreurs

- **Store** : Capture et stocke les erreurs
- **Composant** : Affiche les erreurs de mani√®re appropri√©e
- **Service** : L√®ve des erreurs avec des messages clairs

### 2. √âtats de Chargement

- Centraliser dans le store
- √âviter les √©tats locaux redondants
- Utiliser des computed pour les √©tats d√©riv√©s

### 3. Imports Dynamiques

- Toujours utiliser `await import()` pour les services
- √âviter les imports statiques des services dans les composants

### 4. Props et √âmits

- Props : Donn√©es descendantes
- √âmits : √âv√©nements ascendants
- √âviter les props pour les callbacks

### 5. Composables

- R√©utiliser la logique commune
- S√©parer les pr√©occupations
- √âviter les composables trop gros

## üéØ Exemples Concrets

### ‚úÖ Bon Pattern (Selection)

```typescript
// Store
const downloadAllImagesAsZip = async () => {
  const { selectionService } = await import("~/services/selectionService");
  await selectionService.downloadAllImagesAsZip(selection.value.id);
};

// Composant
const handleDownload = async () => {
  try {
    await selectionStore.downloadAllImagesAsZip();
  } catch (error) {
    toast.add({ title: "Erreur", color: "error" });
  }
};
```

### ‚ùå Anti-Pattern

```typescript
// Composant
const handleDownload = async () => {
  const { selectionService } = await import("~/services/selectionService");
  await selectionService.downloadAllImagesAsZip(selectionId);
};
```

## üìù Checklist de V√©rification

Avant de commiter, v√©rifiez :

- [ ] Les composants n'appellent pas directement les services
- [ ] La logique m√©tier est dans les services/stores
- [ ] Les composants sont focalis√©s sur l'UI
- [ ] Les √©tats sont centralis√©s dans les stores
- [ ] Pas de duplication de logique
- [ ] Gestion d'erreurs appropri√©e √† chaque niveau

## üöÄ Optimisations Avanc√©es

### 1. Cache et Performance

- Utiliser des computed pour les donn√©es d√©riv√©es
- Impl√©menter du cache dans les stores
- √âviter les recalculs inutiles

### 2. Tests

- Tester les services ind√©pendamment
- Mocker les stores pour tester les composants
- Tester la logique m√©tier s√©par√©ment de l'UI

### 3. TypeScript

- Typage strict des stores
- Interfaces claires pour les services
- Props typ√©es pour les composants

Cette architecture garantit une maintenance facile, une r√©utilisabilit√© maximale et une s√©paration claire des responsabilit√©s.
